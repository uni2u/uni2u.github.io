---
layout: post
title: "Docker Overview"
categories:
  - docker
tags:
  - docker
lang: ko
author: "uni2u"
meta: "Springfield"
---

# What is Container?

잘 이해가 되지 않는 운영체제 수준의 가상화 기술이라는 문장으로 설명을 하고 있는데 거두절미하고 __"리눅스 커널을 공유하며 프로세스를 격리된 환경에서 실행하는 기술"__ 로 설명할 수 있다.

- 리눅스 커널을 공유한다는 것은 무엇보다 성능에 대한 장점을 강조하는 것으로 특히, 가상환경 (Virtual Machine) 과 비교할 경우 압도적인 성능 우위를 가질 수 있다.

- 프로세스를 격리된 환경에서 실행한다는 것은 프로세스는 커널을 공유하지만 리눅스 네임스페이스 (Linux Namespaces), 컨트롤 그룹 (cgroup), 루트 디렉토리 격리와 같은 리눅스 커널 기능을 사용한 격리를 의미한다.

```
  Containerized App                VM         VM        VM
/                    \           /     \   /     \   /     \
+---+ +---+ +---+ +---+          +------+  +------+  +------+
| A | | B | | C | | D |          | AppA |  | AppB |  | AppC |
|APP| |App| |App| |App|          +------+  +------+  +------+
+---+ +---+ +---+ +---+          |Guest |  |Guest |  |Guest |
+---------------------+          |    OS|  |    OS|  |    OS|
|    Docker Engine    |          +------+  +------+  +------+
+---------------------+          +--------------------------+
|       Host OS       |          |         Hypervisor       |
+---------------------+          +--------------------------+
|         Infra       |          |           Infra          |
+---------------------+          +--------------------------+
      <Container>                       <Virtual Machine>
```

흔히 말하는 Container 특징은 다음과 같다:

- _운영체제 수준의 가상화_: Hypervisor 없이 리눅스 커널을 공유하여 Container 를 실행하며 GuestOS 가 필요치 않음
- _빠른 성능 및 효율_: HW 에뮬레이션 (Hypervisor) 이 없기 때문에 Container 의 빠른 실행이 가능, 프로세스 격리에 대한 오버헤드는 거의 발생하지 않으며 하나의 머신에서 많은 프로세스를 실행하는 것이 가능함
- _높은 이식성 (portability)_: 모든 Container 는 독자적인 실행 환경을 가지고 있으며 환경들은 파일로 구성되고 이미지를 공유함, 같은 Container 런타임을 사용하는 경우 Container 실행 환경 공유
- _stateless_: 독립적인 Container 실행 환경은 다른 Container 에 영향을 주지 않음, 특히 Docker 와 같이 이미지 기반으로 Container 를 실행하는 경우 특정 실행 환경의 재사용 가능

## Container Type

Container 는 크게 시스템 Container 와 애플리케이션 Container 로 나뉜다.

- __System Container__
  - Container 를 통해 OS 위에 HW 가상화 없이 OS 실행
  - 리눅스 처럼 init 프로세스를 사용하여 다수의 프로세스가 같은 환경을 공유하는 것을 목표로 함
  - 대표적인 System Container Runtime: LXC 와 LXD
- __Application Container__
  - Container 를 통해 하나의 애플리케이션 (process) 을 실행
  - 단 하나의 process 를 실행하기 때문에 확장이 쉽고 관리 요소가 작음
  - 대표적인 Application Container Runtime: Docker

## Why Container

서버 운영을 하는데 있어 Container 의 등장은 서버 Application 의 배포 단위의 변화를 가지고 왔다. 기존 서버 운영에는 Application 운영을 위해 서버 컴퓨터의 상태를 관리하여야 했지만 Container 의 사용으로 인하여 Application 별 환경 구성이 가능하기 때문에 서버 컴퓨터 관리 필요성이 줄어들었다.

이는 _Snowflake Servers_ 문제를 해소할 수 있다는 점이 가장 큰 이유로 작용한다.

서버 구성에 있어 구성 시기, 라이브러리, 버전 등과 같은 여러 이유로 인하여 완벽하게 같은 서버 구성이 불가능하다. 조금씩 차이가 있어도 구성 시점에는 동작이 가능한 서버를 가리켜 Snowflack Servers 라고 한다. 이것의 문제는 구성 시점에는 아무런 문제가 없었지만 시간이 지나면서 발생하는 장애 문제를 해결할 수 없는 상태가 되는 것이다.

```
+----------+                       +----------+
| Ansible  |-----[1년전 구성]----->| Server A |<---+
|          |---+                   +----------+    |
+----------+   |                              1년 차이
               |                   +----------+    |
               +---[오늘 구성]---->| Server B |<---+
                                   +----------+



+----------+                   +------------+                   +----------+
|Dockerfile|---[1년전 빌드]--->|Docker Image|---[1년전 실행]--->| Server A |<---+
+----------+                   +------------+                   +----------+    |
                                        |                                차이 없음
                                        |                       +----------+    |
                                        +------[오늘 실행]----->| Server B |<---+
                                                                +----------+
```

위 그림처럼 배포 도구인 Ansible 을 사용하여도 설치하는 시점에 따라 서버의 상태가 결정되는데 이 조그마한 차이가 나중에 큰 문제를 발생할 수 있다는 것이다. 반면 Docker 의 경우 Dockerfile 을 사용하여 설치에 대한 모든것이 동일화 되는 장점이 있다.

## Container Environment CASE

프로덕션 레벨로 사용하는 가장 큰 예는 Google 이다. Container Orchestration Tool 인 Kubernetes 를 제작한 것에서 알 수 있듯 2014년 모든 서비스를 Container 로 운영하고 있다. (https://speakerdeck.com/jbeda/containers-at-scale?slide=2)

Google 을 필두로 Netflix, [Airbnb](https://www.infoq.com/presentations/airbnb-kubernetes-services/), [Pinterest](https://kubernetes.io/case-studies/pinterest/), [Reddit](https://www.youtube.com/watch?v=z7TIzCAEo0M), [Riot Games](https://www.youtube.com/watch?v=ChQmDDy0FRY) 등 수많은 곳에서 Container 서비스를 운영하고 있다.

물론 국내에서도 이 움직임이 가속화되고 있으며 이미 [삼성](https://www.youtube.com/watch?v=AebQVeykk8o&feature=emb_title), [당근마켓](https://medium.com/daangn/%EB%94%A5%EB%9F%AC%EB%8B%9D-%EC%B6%94%EC%B2%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-in-production-fa623877e56a), [NCsoft](https://byline.network/2019/08/8-51/), [TOSS](https://blog.toss.im/2019/11/26/tossteam/people/serverplatformteam-interview/) 등에서 활용중이다.

## Container Runtime

Container 를 실행하고 관리하는 도구를 가리켜 Container Runtime 이라고 한다.

### Docker

이제는 "Container = Docker" 라는 말이 의문스럽지 않을 정도이다. 'PyCon 2013 US' 에서 dotCloud 의 솔로몬 하익스 (Solomon Hykes) 가 최초로 발표한 Application Container Runtime 을 지향하는 모델이다.

#### Docker Hub

Docker 에서 제공하는 공식 원격 이미지 저장소이다. 기존의 많은 기술들이 실행 환경을 공유하는 것에 대한 어려움으로 접근성이 떨어졌었다. System Container 의 경우 실행 환경이 무거우며 변경 사항을 저장하고 공유하는 것이 어려운데 Docker 는 _'리눅스 커널 병합 마운트 (union mount)'_ 기반의  이미지 개념으로 실행 환경을 관리하고 적절한 단위로 공유할 수 있다.

원격 저장소는 직접 설치하여 운용하는 것도 가능하다. 이미 클라우드 서비스에서는 프라이빗 이미지 저장소를 서비스로 제공하고 있는데 대표적으로 [AWS ECR Elastic Container Registry](https://aws.amazon.com/ko/ecr/), [MS Azure Container Registry](https://azure.microsoft.com/ko-kr/services/container-registry/), [CNCF Harbor](https://goharbor.io/) 등이 있다.

#### Docker Compose

다수의 Container 를 관리할 수 있는 도구로서 YAML 형식으로 Container 명세서를 작성한 후 Container 를 한꺼번에 실행시키거나 종료할 수 있다. 보통 로컬 개발 환경 구성에 사용하거나 Container Orchestration 구성 이전 초기 단계의 배포에 사용된다.

## Container Orchestration

Container 환경의 발전으로 인하여 프로덕트 레벨에서 Container 를 사용하기 시작했고 이를 관리하기 위해서 다수의 Container 를 분산하고 스케줄링하기 위한 도구의 필요성이 강조되고 있다. 가장 대표적인 것이 Google 에서 주도하고 현재 CNCF 에서 관리하는 _'Kubernetes'_ 이다.

### Kubernetes

Google 의 _Joe Beda_, _Brendan Burns_, _Craig McLuckie_ 의 주도로 시작된 Container Orchestration 도구로 2014년 OpenSource 로 공개되었다. 무엇보다 Google 에서 주도한 Container Orchestraion 도구라는 점에서 매우 빠르게 표준과 같이 자리잡았다.

### AWS ECS

AWS ECS (Elastic Container Service) 는 완전 관리형으로 제공되는 Container Orchestration 도구로서 개념이 단순하고 AWS 서비스들과 궁합이 좋다는 장점과 함께 커뮤니티가 작고 오픈소스가 아니라는 단점이 동시에 존재한다. 이 때문인지 몰라도 AWS 에서는 Kubernetes Master 노드를 관리형으로 제공하는 EKS (Elastic Kubernetes Service) 도 함께 제공하고 있는데 심지어 EKS 의 사용율이 훨씬 높다.

### Rancher

Kubernetes 기반의 Container Orchestration 도구로서 1.0 버전은 Docker 기반의 Container Orchestration 이었으나 2.0 버전 부터는 Kubernetes 를 기반으로 동작한다.

### Nomad

오픈소스 인프라 관련 도구를 만드는 _HashiCorp_ 에서 제공하는 Container Orchestration 도구이다. 특히 task 와 scheduling 에 집중하고 있으며 다른 도구에 비해 비교적 단순함을 제공한다.

## Process Isolation

Container 에서 process (프로세스) 를 격리하기 위하여 _Linux Namespace_, _root directory isolation: chroot_, _control group: cgroup_, _Linux capabilities_, _Union Mount_ 등의 커널 기능을 활용한다.

### Linux Namespace

특정 process 의 리소스 접근을 제어하기 위해 사용되는 기능이다. 리소스별로 _IPC Namespace_, _Mount Namespace_, _Network Namespace_, _Process ID Namespace_, _User Namespace_, _UTS Namespace_, _Control Group Namespace_ 등으로 나뉜다. 시스템에서 실행되는 process 들은 기본적으로 init process 의 namespace 를 공유하지만 시스템 콜이나 unshared 명령어를 사용해 리소스 별 namespace 를 분리하는 것도 가능하다.

### root directory isolation: chroot

Container 는 Host 의 파일 시스템이 아닌 별도의 실행 환경을 가지고 있다. 'root directory 격리' 는 이와 같은 Container 의 별도 실행 환경에 대한 바탕을 제공한다. 그 중에서 _chroot_, _pivot root_ 같은 시스템 콜을 사용하여 process 가 바라보는 root directory 를 파일 시스템의 특정 directory 로 변경하는 것이 가능하다. 

### control group: cgroup

process 에서 사용 가능한 _CPU_, _Memory_, _Network bandwidth_, _DISK I/O_ 등을 그룹 단위로 제어하는 Linux 커널의 기능으로 Linux 전체 시스템에서 process 관리를 위해 사용되고 있다.

### Linux capabilities

process 권한을 제어하는 기능으로 크게 _root 권한 사용자_ 로 실행되는 process 와 _일반 사용자_ 가 실행하는 process 로 구분된다. root 의 권한을 세분화하여 process 에 적용할 수 있도록 만든 기능으로 Container Runtime 에서 일부 root 권한이 필요한 경우 이를 활용하여 권한을 지정하는 방식을 사용한다.

### Union Mount

계층화된 파일 시스템을 구현하는 것으로 Docker 에서 이미지 구현에 사용되고 있다. Docker image layer 구현의 핵심으로 활용되며 image build 과정에서 캐시를 사용하거나 image 관리에 장점이 있다.

---
layout: post
title: "IPFS 프로토콜 Kademlia 기본 모델 계층 분석"
categories:
  - ipfs
  - Distributed File System
tags:
  - ipfs
lang: ko
author: "uni2u"
meta: "Springfield"
---

# 분산 시스템

기존의 라우팅 프로토콜에서는 다른 노드를 찾는 서비스를 제공하는 중앙 집중식 서버가 존재합니다. 상호 연결을 구현해야하는 경우 동일한 중앙 서버에 등록해야 합니다. 이러한 방식으로, 사용자의 고유 식별 정보에 기초하여 두 당사자에 대한 연결이 성립 될 수있습니다. 분산 시스템에서는 어느 누구도 각 노드의 정보를 관리하지 못합니다. 노드와 노드는 상호 연결되어야 합니다. 특정 알고리즘과 방법을 통해 서로를 찾고, 서로를 식별하고 연결을 설정해야 합니다. 각 노드에는 온라인 네트워크 노드를 나타내는 고유 `node_id` 가 있습니다.

![](/images/ipfs_kademlia_01.png)

## Kademlia 기본 모델

네트워크의 다른 노드를 빠르게 찾고 네트워크 연결 관계를 유지하려면 현재 노드와 다른 노드 사이의 거리를 계산해야 합니다. kademlia DHT 디자인에서  XOR 연산을 사용하여 거리를 계산합니다. 노드 간의 거리와 거리를 기반으로 네트워크 라우팅 정보를 유지하는 방법은 물리적 거리가 아니라 노드 ID 사이의 비트 거리입니다.

### XOR 연산

![](/images/ipfs_kademlia_02.png)

첫 번째 연산은 XOR 연산이며, 두 비트의 값이 같으면 XOR 연산의 결과는 `0` 입니다. 두 비트의 값이 다른 경우 연산 결과는 `1` 이되고 두 네트워크 노드의 ID를 기반으로 이와 같이 계산합니다. 거리는 그림과 같이 노드 x의 id 값이 0011 인 것으로 가정하고, 대상 노드 1110 사이의 거리를 계산하면 결과는 1101 입니다. 이 연산을 기반으로 다음과 같은 계산을 유도합니다.

![](/images/ipfs_kademlia_03.png)

위 그림에서 A 노드 ID에서 다른 노드 ID를 찾는 과정을 간단하게 나열하면 다음과 같습니다.

- 0번째 비트가 있는 A 노드에는 _1_ 이 있음
- 처음 세자리는 001 이며 마지막만 다른 노드 즉, ID가 _0010_ 인 노드가 있을 수 있음
  - 해당 노드는 XOR 연산에 따라 거리가 1 임을 알 수 있음
- 1번째 비트를 위와 같이 바라보면 노드와 다른 ID를 가진 노드는 2가지가 있을 수 있음
  - _0000_, _0001_ 임을 알 수 있음
  - 즉, 노드 ID가 _00_으로 시작하는 노드가 있음을 알 수 있음
- 2번째 비트를 위와 같이 바라보면 노드와 다른 ID를 가진 노드는 4가지가 있을 수 있음
  - _0100_, _0101_, _0110_, _0111_ 임을 알 수 있음
  - 즉, 노드 ID가 _0_으로 시작하는 노드가 있음을 알 수 있음
- 3번째 비트를 위와 같이 바라보면 노드와 다른 ID를 가진 노드는 8가지가 있을 수 있음
  - _1000_, _1001_, _1010_, _1011_, _1100_, _1101_, _1110_, _1111_ 임을 알 수 있음
  - 즉, 노드 ID가 _1_로 시작하며 노드 ID와 공통 시작점을 가지고 있지 않음
- 이러한 계산을 통하여 A 노드 _0011_ 과의 거리에 따라 다른 카테고리로 나눌 수 있음
  - 0번째 비트와의 거리는 '1'
  - 1번째 비트와의 거리는 '2~3'
  - 2번째 비트와의 거리는 '4~7'
  - 3번째 비트와의 거리는 '8~15'

즉, i 번째부터 시작하는 노드와의 거리는 현재 노드의 $$[2^i, 2^{i+1}]$$ 입니다. 이를 이진트리 형식으로 표현하면 다음과 같습니다.

![](/images/ipfs_kademlia_04.png)

영역 1, 2, 3 및 4 는 위 그림의 0, 1, 2 및 3 번째 비트에서 자신의 노드 0011의 id와 다른 노드 그룹에 해당합니다. 이진 트리의 경로는 노드 번호의 각 비트의 값으로 나타냅니다. 리프 노드는 네트워크 노드 번호이며 그 값은 루트 노드에서 리프 노드까지의 경로입니다.

![](/images/ipfs_kademlia_05.png)

위의 디자인 다이어그램에서 src 노드에서 dst 노드를 찾을 때 먼저 위의 지식을 기반으로 src 노드와 dst 노드 사이의 거리를 계산 한 다음 거리와 일치하는 노드 그룹을 찾습니다. 자신의 하프 존에없는 노드와 자신보다 거리가 절반 정도 짧은 대상 노드인 a 노드를 찾습니다. a 노드는 자신의 라우팅 거리 테이블에서 dst 노드까지 거리보다 절반 짧은 노드인 b 노드를 찾습니다. b 노드는 반복적으로 dst 노드를 찾을 수 있도록 합니다.

이 방법으로 경로를 찾으면 전체 네트워크에 n개의 노드가 있는 경우 최악 검색 속도는 n의 2 로그입니다. 이 알고리즘은 매우 빠른 검색 알고리즘입니다. 노드가 100만 개이면 검색은 최대 20회만에 대상 노드를 찾을 수 있습니다.

### 

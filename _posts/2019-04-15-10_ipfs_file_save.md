---
layout: post
title: "IPFS - file save"
categories:
  - IPFS_Review
tags:
  - IPFS_file_save
lang: ko
author: "uni2u"
meta: "Springfield"
---

# IPFS 는 어떻게 파일을 저장합니까?

IPFS 파일의 저장 및 읽기는 BitTorrent 업로드 및 다운로드의 원칙과 유사합니다. IPFS에서 채택한 인덱스 구조는 DHT (Distributed Hash Table) 이며 데이터 구조는 MerkleDAG (Merkle Directed Acyclic Graph) 입니다.

## IPFS 단일 파일 저장소

파일 시스템을 연구 한 사람들은 인덱스와 섹터라는 두 가지 개념을 알고 있습니다. 예를 들어 NTFS 섹터는 보통 4K 이고 실제 파일 데이터는 섹터에 저장됩니다. 이러한 섹터를 찾는 방법은 인덱스를 만드는 것입니다. IPFS 는 파일 시스템이기도하지만 IPFS 에는 저장 용량 제한이 없으며 공간 복구 기능도 없다는 점이 다릅니다. IPFS 가 파일을 저장하면 다음 단계를 수행합니다:

1. 단일 파일을 256KB 크기의 여러 블록으로 분할합니다. (블록, 섹터로 이해할 수 있음)
2. 블록 (block) 당 blockhash 를 계산합니다. _hashN = hash(blockN)_
3. 모든 blockhash 를 배열에 넣은 다음 해시를 계산하면 파일의 최종 해시인 _hash(file) = hash(hash1...N)_ 이 생성되고 hash(file) 와 blockhash 배열을 묶어 객체를 구성하고 객체를 인덱스 구조로 처리합니다.
4. IPFS 노드에 블록 및 인덱스 구조를 업로드 합니다. 파일은 IPFS 네트워크와 동기화 됩니다.

여기에는 또한 작은 파일의 처리 논리가 누락되어 있으며 NTFS 와 같은 파일 시스템과 유사하게 작은 파일 (1KB보다 작음) 은 IPFS 가 데이터 콘텐츠를 직접 해시 (인덱스) 와 함께 배치하여 하나의 IPFS 노드 블록에 업로드하는 일이 더 이상 없습니다. 이것으로 파일의 원래 데이터와 파일 인덱스 (예: 해시)가 IPFS 네트워크에 업로드 되었습니다. IPFS 는 교정을 지원하지 않습니다. 일단 파일이 IPFS 와 동기화되면 영구히 존재하게 됩니다.

대규모 파일을 자주 편집하는 경우 편집 할 때마다 다시 동기화해야 합니다. 그렇다면 너무 많은 공간을 낭비하지 않을까요? 다음을 보면 알 수 있습니다.

예를 들어 IPF 에 동기화 된 1G 의 File1 이라는 큰 파일이 있습니다. 이 파일 File1 뒤에 1K 내용을 추가 한 후 이 파일을 다시 동기화해야 합니다. 계산해야 할 공간은 1G + 1G + 1K 입니다.  IPFS 가 데이터를 저장하면 동일한 데이터가 한 번만 저장되며 파일은 블록으로 저장됩니다. 동일한 해시 블록은 한 번만 저장됩니다. 즉 이전 1G 의 내용은 변경되지 않았습니다. IPFS 는 데이터의 마지막 1K 에 대하여만 블록이 할당되고 해시는 다시 업로드 됩니다. 실제 점유 공간은 1G + 1K 입니다.

자막이 있는 영화는 오디오 및 비디오 부분이 같고 자막이 다른 경우를 생각해보면 각기 다른 국가의 두 사람이 같은 영화를 업로드 할 때 이러한 파일이 블록에 있습니다. (block) 대부분의 블록 해시가 일관성이 있을 가능성이 높습니다. 이 블록은 하나의 복사본만 IPFS 에 저장하므로 동일한 블록을 가리키는 많은 파일 인덱스가 있을 수 있습니다. 이는 MerkleDAG 데이터 구조를 의미 합니다.

해시는 모든 인덱스에 저장되기 때문에 MerkleDAG 에는 다음과 같은 기능이 있습니다 (whitepaper 내용): 1) Content based Addressing: 모든 내용은 링크를 포함하여 여러 해시 체크섬으로 고유하게 식별됩니다. 2) 위조 할 수 없음: 모든 내용이 체크섬으로 확인됩니다. 데이터가 훼손되거나 손상되면 IPFS 가 탐지합니다. 3) 중복 제거: 콘텐츠를 복제하고 한 번만 저장합니다.

## IPFS 디렉토리 파일 저장

IPFS 는 디렉토리 구조를 지원하며 저장은 다음과 같습니다:

1. 먼저 디렉토리의 모든 파일을 IPFS 네트워크와 동기화하고 모든 파일 해시에 대한 별칭을 만듭니다. 이 별칭은 실제로 로컬 파일 이름입니다. 해시와 별칭은 IPFSLink 라는 객체를 형성하기 위해 함께 '번들링 (결합; 묶음)' 됩니다.
2. 디렉토리의 모든 IPFSLink 객체를 배열로 만들고 배열에 대한 디렉토리 해시를 계산하고 배열과 디렉토리 해시를 구조로 결합하고 IPFS 네트워크에 동기화 합니다.
3. 상위 계층에 디렉토리 구조가 있으면 디렉터리 해시에 별칭  (즉, 디렉토리 이름) 이 만들어지고 IPFSLink 객체를 만들기 위해 디렉토리 해시와 별칭이 함께 '번들'로 포함되며 실행은 2 단계를 반복합니다.
4. 디렉토리 해시를 출력하고 읽을 때 사용됩니다.

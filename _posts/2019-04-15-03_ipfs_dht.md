---
layout: post
title: "IPFS - DHT"
categories:
  - IPFS_Review
tags:
  - IPFS_DHT
lang: ko
author: "uni2u"
meta: "Springfield"
---

# IPFS 기술 배경: 분산 해시 테이블 DHT

## Kademlia DHT

Kademlia DHT 는 KAD 라고도 하며 향상된 DHT 입니다.
간단한 분석은 다음과 같습니다: 
새로 추가 된 노드는 먼저 노드의 IP 주소에 따라 노드 ID 를 임의로 생성하고 시드 노드를 통해 자신의 ID 와 유사하거나 다른 거리의 노드를 가져 와서 160K 버킷을 생성합니다. K 버킷 노드 정보에는 IP 주소, UDP 포트 및 NodeID 가 있습니다. 또한 <key, value> 유형의 파일 저장 정보 DHT 테이블이 있는데 key 는 저장된 파일의 해시값, value 는 저장된 파일의 노드 ID 입니다. 네트워크의 각 노드는 노드 ID 와 거리가 작은 파일을 우선적으로 저장합니다. (XOR 결과)

## Coral DSHT

Coral 은 DSHT 라는 개념을 제공합니다. DSHT 는 서로 다른 값이 동일한 키를 가질 수있는 key/value 기반 저장 메커니즘을 제공합니다. CoralCDN 은 이 구조를 통해 다양한 CoralCDN 노드에 다양한 키를 매핑합니다. 특히 이 메커니즘을 통해 CoralCDN 은 클라이언트에 더 가까운 DNS 서버를 찾을 수 있으며 클라이언트에 더 가까운 웹 데이터가 있는 HTTP 프록시는 작은 지연으로 Coral 노드를 찾을 수 있습니다.

일반 오버레이 네트워크와 달리 모든 Coral 노드는 여러 독립적인 DSHT (클러스터라고 함) 에 속합니다. 각 클러스터는 최대 RTT 에 따라 분할됩니다. 이 시스템은 서로 다른 RTT 표준에 따라 여러 레이어로 나뉩니다. 모든 노드는 특정 계층의 노드 입니다. Coral 에서 DSHT 는 다음과 같이 세 가지 레이어로 나뉩니다:

- Level-2 는 두 쌍 모두 20 밀리 초 미만의 지연에 해당하며 범위에 빠르게 응답하는 클러스터 입니다. (regional coverage; 지역 범위)
- Level-1 은 두 쌍의 지연 시간 범위가 60 밀리 초 미만의 지연을 보이는 클러스터 입니다. (continental coverage; 대륙 범위)
- Level-0 는 다른 모든 노드에 해당하며 지연 시간 무한대이며 지연 적용 범위가 없는 클러스터 입니다. (planet-wide)

Coral 은 상위 수준의 빠른 노드를 요청한 다음 하위 수준의 느린 노드를 요청합니다. 이를 통해 응답 시간을 효과적으로 줄이고 거리가 가까운 노드를 찾을 수 있습니다.

Coral 은 응용 프로그램에 대해 다음 인터페이스를 제공합니다:

- `Put(key, val, ttl, [levels])`: 값 매핑에 키를 삽입하고 시간을 지정합니다. 인터페이스 호출자는 작업 계층 수를 지정할 수도 있습니다.
- `Get(key, [levels])`: 키에 해당하는 값을 가져오고 마찬가지로 가져올 레이어를 지정할 수 있습니다.
- `nodes(level, count, [target], [services])`: 계층화 된 인접 노드 수를 반환합니다. 대상이 지정되면 대상에 가까운 노드가 반환되고 Coral 은 대상을 검색 한 다음 요구 사항을 충족하는 노드를 반환합니다. 서비스가 설정된 경우 Coral 은 지정된 서비스를 실행하는 노드 (예: HTTP 프록시 또는 DNS 서버) 만 반환합니다.
- `levels()`: 레이어 수와 해당 RTT 경계를 반환합니다.

## S/Kademlia DHT

Kademlia 프로토콜은 완전히 열린 P2P 네트워크에 적용되며 보안 대책을 제공하지 않기 때문에 악의적인 노드 공격에 취약합니다. Kademlia 를 기반으로하는 S/Kademlia 프로토콜은 노드 ID, 브로드캐스트 및 분리 된 경로 쿼리 알고리즘을 무작위로 생성하도록 노드를 제한하는 것을 포함하여 공격에 대한 저항 전략을 확장합니다.

### Kademlia 문제점

주로 두 가지 범주로 나뉘어 지는데 하나는 라우팅 테이블이 네트워크의 일부 노드를 제어하기 위한 것이고 다른 유형은 점유된 노드를 악의적으로 사용하는 리소스 입니다.

- Sybil attack
Sybil attack 은 P2P 네트워크에서 발생합니다. 노드가 언제든지 조인하고 나가기 때문에 네트워크 안정성을 유지하기 위해 일반적으로 같은 데이터를 여러 분산 노드에 백업 (데이터 중복 메커니즘) 해야 합니다. Sybil attack 은 데이터 중복 메커니즘을 공격하는 효과적인 수단입니다. 네트워크에 악성 노드가있는 경우 동일한 악성 노드가 여러 개의 ID를 가질 수 있습니다. 여러 노드에 백업해야 하는 데이터는 동일한 악의적인 노드로 스푸핑되어 악의적인 노드가 Sybil attack 을 위한 다중 ID로 가장합니다.

- Eclipse attack
Eclipse attack 은 주로 단일 노드를 공격하며, 공격의 주요 대상은 노드의 K-버킷 입니다. 공격자는 자신의 ID 를 자유롭게 선택할 수 있습니다. 공격자의 K-버킷이 가득 차거나 내부 노드가 ping 되면 악의적 노드가 K-버킷에 들어갈 수 있습니다. 악의적 노드가 K-버킷을 제어하고 정보가 악의적 노드를 통해 전송되므로 공격자는 전체 네트워크에 영향을 미칠 수 있습니다.

- Churn attack
공격자는 많은 노드를 제어하고 즉시 네트워크에서 노드를 소모하므로 네트워크 안정성이 저하됩니다.

- Adversarial routing
질의 명령을 수신한 후 악의적 노드는 KAD 의 요구 사항에 따라 키에 가장 가까운 네트워크 노드를 반환하지 않고 파트너 노드로 전달하여 쿼리 효과를 발생시킵니다. 이러한 적대적인 라우팅 공격을 피하기 위해 병렬 쿼리 (각 쿼리 경로는 교차하지 않음) 를 수행하고 병렬 쿼리 경로 중 하나가 도착하면 성공적인 쿼리를 나타냅니다.

### S/Kademlia 보안 정책

[1] 제어 노드 ID 생성은 노드 ID 가 임의로 선택 될 수 없으며 노드 ID 가 대량으로 생성 될 수 없으며 노드 ID 를 도용 또는 위장 할 수 없도록 합니다. 이런 식으로 Sybil attack 과 Eclipse attack 이 해결됩니다.

S/Kademlia 는 각 노드가 네트워크에 액세스하기 전에 두 가지 암호화 문제를 해결해야한다고 요구합니다.

정적 문제: 한 쌍의 공개 키와 개인 키가 생성되고 공개 키가 두 번 해시 된 후 C1 키가 0으로 설정됩니다. 공개 키의 해시는 노드의 NodeID 입니다.

동적 문제: 끊임없이 난수 X 를 생성하고 X 및 노드 ID 를 XOR 하여 해시 값을 요청하면 해시 값에 C2 선행 제로가 필요합니다.

다음 그림은 이 두 가지 수학적 문제를 푸는 과정을 설명합니다.

![](https://ai2-s2-public.s3.amazonaws.com/figures/2017-08-08/02190db89bf2d898817aa600c3edca6ded294de0/4-Figure3-1.png)

이러한 방식으로 첫 번째 정적 문제는 노드가 더 이상 자유롭게 노드 ID 를 선택할 수 없도록하고 후자의 동적 문제는 많은 수의 ID 를 생성하는 비용을 증가 시킵니다. Sybil attack 과 Eclipse attack 은 어려울 것입니다.

[2] 분리된 경로 질의 알고리즘

Kademlia 프로토콜에서 α K-Buckets 의 노드에 액세스 한 다음 정렬하면 첫 번째 α 연속 반복 요청이 선택됩니다. 단점은 분명합니다. 악성 노드가 있으면 쿼리가 실패 할 수 있습니다.

S/Kademlia 는 쿼리 당 k 개의 노드를 선택하고이를 서로 다른 버켓에 넣을 것을 제안합니다. d 버킷이 검색되고 d 쿼리 경로가 연결되지 않고 단일 버킷에 오류가 발생할 수 있지만 d 버킷 중 하나에 필요한 정보가 있으면 작업이 완료됩니다. 적대적인 라우팅 공격은 분리 된 경로 쿼리로 해결됩니다.
